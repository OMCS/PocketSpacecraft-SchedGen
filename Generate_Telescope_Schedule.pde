/*

PocketSpacecraft.com Ground Station FoV Survey Schedule Generator (v0.4) - Oliver Saunders (o.saunders at me.com) - July 2014

This application creates a tab-separated schedule file for use with 'Coldstream' radio telescope control software.
In future versions it could be adapted to work with other radio telescopes.

The current file generated by this implementation surveys the area around the telescope in 
altitude increments of 10 degrees, azimuth increments of 10 degrees and allows for a 20 second integration period.
This will take just under 2 hours (~108 minutes) for a full cycle. 

Please see the 'draw' function for an explanation of the output file format.

Revisions:

0.1 - Initial implementation in Python (8 July 2014)
0.2 - Rewrite in Processing (9 July 2014)
0.2a - Added comments, changed variable names, general cleanup (9 July 2014)
0.3 - Changed telescope movement to reduce motor wear, changed all magic numbers to constants, readability improvements (10 July 2014)
0.3a - Added functionality to return telescope to safe position, additional comments throughout (10 July 2014)
0.4 - Adjusted nextPosition function to allow for 5 degree special case, updated documentation (11 July 2014)

To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights 
to this software to the public domain worldwide. This software is distributed without any warranty.
You should have received a copy of the CC0 Public Domain Dedication along with this software. 
If not, see http://creativecommons.org/publicdomain/zero/1.0/.

*/

/*                                                          CONSTANTS - Modify if required                                                    */

/* 
 * Minimum and maximum elevation and rotation for telescope, typically ~5 to 90 and 0 to 350
 */
final int MINIMUM_ELEVATION_IN_DEGREES = 5; // Many radio telescopes cannot go below 5 degrees elevation, the increment is adjusted to allow for this
final int MAXIMUM_ELEVATION_IN_DEGREES = 90; 

final int MINIMUM_ROTATION_IN_DEGREES = 0; 
final int MAXIMUM_ROTATION_IN_DEGREES = 350;

/* Define safe position */
final int SAFE_ELEVATION_IN_DEGREES = 90; // Straight up
final int SAFE_ROTATION_IN_DEGREES = 180; // Neutral point

/* The elevation and rotation in degrees between each successive observation */
final int DEFAULT_ELEVATION_INCREMENT_IN_DEGREES = 10;
final int DEFAULT_ROTATION_INCREMENT_IN_DEGREES = 10;

/* Define the point where the altitude increment can be increased as the sky is likely to be empty */ 
final int ELEVATION_CUTOFF_POINT_IN_DEGREES = 70;

/* This is the number of seconds between each observation 
 * It is CRUCIAL that this be a sensible amount of time, if an observation does not complete on time and the
 * UTC Start Time field is set to 0, the next observation will start the next DAY
 * Slewing rates differ amongst telescopes, experimentation will be required 
 */
final int INTEGRATION_PERIOD_IN_SECONDS = 20; 

/* Name of output file */
final String OUTPUT_FILE_NAME = "Telescope_Schedule.txt";

/*                                                          END OF CONSTANTS                                                                       */

/* Variables for the elevation and rotation, begin at minimum values */
int nCurrentElevationInDegrees = MINIMUM_ELEVATION_IN_DEGREES;
int nCurrentRotationInDegrees = MINIMUM_ROTATION_IN_DEGREES;

/* Set the increments to the default values */
int nElevationIncrementInDegrees = DEFAULT_ELEVATION_INCREMENT_IN_DEGREES;
int nRotationIncrementInDegrees = DEFAULT_ROTATION_INCREMENT_IN_DEGREES;

/* Boolean condition to determine direction telescope is rotating (to or away from 360 degrees) */
boolean bRotateTowardsThreeSixty = true;

/* Counts the number of positions recorded so far, used for status output */
int nPosNum = 0;

/* Data structure for tab-separated output file */
/* XXX: For portability it would be a good idea to replace this with an array and direct file-writing at some point */
Table tblSchedule; 

void draw()
{ 
  frame.removeNotify(); // Hide GUI window
  
  tblSchedule = new Table(); // Instantiate table
   
  /* The file output format is explained below, many columns will be filled with zeroes or dummy data.
  * This is because the radio telescope that uses this file format is usually paired with a spectrometer
  * and anything relating to that is not required for other applications
  *
  * Beside each heading you will find a description and instructions on how to use the file format
  * ALL fields MUST have a value, even if it is a placeholder
  */
  
  /* These first three headings are arbitrary */ 
  tblSchedule.addColumn("Title"); // Name of log file
  tblSchedule.addColumn("Project"); // Name of directory
  tblSchedule.addColumn("File Base Name"); // Prefix of data file(s)
     
  /* These 3 headings are required */
  tblSchedule.addColumn("Coord Type"); // Type of coordinates, AZEL (Azimuth / Elevation), J2000, etc.
  tblSchedule.addColumn("Start Longitude"); // Longitude refers to Azimuth (Rotation, 0 - 350 degrees)
  tblSchedule.addColumn("Start Latitude"); // Latitude refers to Elevation (0 - 90 degrees)
     
  /* These two headings are not currently used, set them the same as the start latitude / longitude */
  tblSchedule.addColumn("End Longitude");
  tblSchedule.addColumn("End Latitude");
     
  /* These five columns are used by the spectrometer, set them all to '0' */
  tblSchedule.addColumn("Velocity Offset");
  tblSchedule.addColumn("Rest Frequency");
  tblSchedule.addColumn("Frequency Delta");
  tblSchedule.addColumn("Start Cal Time");
  tblSchedule.addColumn("End Cal Time");
     
  tblSchedule.addColumn("Integration Period"); // Time between successive readings, set to 20 seconds at the top of this file
  tblSchedule.addColumn("Start Time"); // Start time in UT1, e.g. 19:45:30. '0' means start as soon as possible. Cannot be more than 24 hours in advance 
  tblSchedule.addColumn("Reference"); // Set this to 'NO'
  tblSchedule.addColumn("Epoch"); // Deprecated, make this the same as the 'Coord Type'

  /* Main loop, while the elevation is below the maximum, keep adding positions to the schedule file and move on to the next position */
  while (nCurrentElevationInDegrees <= MAXIMUM_ELEVATION_IN_DEGREES)
  {
    addPositionToSchedule(); // Write the current position into the schedule file
    nextPosition(); // Finished this set of readings, rotate to next position (change rotation and / or elevation)
  }

  /* Survey complete - place telescope in safe position (neutral, facing upwards) */
  nCurrentRotationInDegrees = SAFE_ROTATION_IN_DEGREES;
  nCurrentElevationInDegrees = SAFE_ELEVATION_IN_DEGREES;

  addPositionToSchedule(); // Write the safe position as the final entry in the schedule file

  /* 
   * Create TSV file with .txt extension, write tab separated header and all data stored in Table object to it
   * This can then be used to control the telescope 
   */
  saveTable(tblSchedule, OUTPUT_FILE_NAME, "tsv");

  print("\nSchedule saved to " + OUTPUT_FILE_NAME + "\n");
    
  exit(); // Call to exit required or program will loop indefinitely 
}

/* This function adds a position to the Table object that will become the schedule file used with the telescope */
void addPositionToSchedule()
{
  /* See the 'draw' function for an explanation of the schedule format */ 
  TableRow newPosition = tblSchedule.addRow();
  
  /* These fields will be the same for every observation - set your paramters here */
  newPosition.setString("Title", "PocketSpacecraft");
  newPosition.setString("Project", "MGS-NEO2-44117A");
  newPosition.setString("Coord Type", "AZEL");
  newPosition.setInt("Velocity Offset", 0);
  newPosition.setInt("Rest Frequency", 0);
  newPosition.setInt("Frequency Delta", 0);
  newPosition.setInt("Start Cal Time", 0);
  newPosition.setInt("End Cal Time", 0);
  newPosition.setInt("Integration Period", INTEGRATION_PERIOD_IN_SECONDS);
  newPosition.setString("Start Time", "0"); 
  newPosition.setString("Reference", "NO");
  newPosition.setString("Epoch", "AZEL");
  
  /* The azimuth and elevation will be dynamically set here */
  newPosition.setInt("Start Longitude", nCurrentRotationInDegrees); 
  newPosition.setInt("Start Latitude", nCurrentElevationInDegrees);

  /* The current control software ignores these values, set them to the same as the start values */
  newPosition.setInt("End Longitude", nCurrentRotationInDegrees);
  newPosition.setInt("End Latitude", nCurrentElevationInDegrees);

  /* The file basename will include the position information for debugging purposes - e.g. AZ20_EL10 */
  newPosition.setString("File Base Name", "AZ" + nCurrentRotationInDegrees + "_EL" + nCurrentElevationInDegrees);

  print("Position " + (nPosNum + 1) + " added\n");
  nPosNum++; 
}

/* This function generates a new position using the *_INCREMENT_IN_DEGREES values and the current elevation and rotation */
void nextPosition() 
{
  /* This block sets the appropriate increment for all three cases: minimum elevation, elevation below cutoff point but above minimum, elevation above cutoff point */
  if (nCurrentElevationInDegrees == MINIMUM_ELEVATION_IN_DEGREES)
  {
    /* SPECIAL CASE: If the start elevation is 5 degrees, this will record at 5 degrees and ensure the next position will be a multiple of the increment - e.g. 10 degrees */
    nElevationIncrementInDegrees = DEFAULT_ELEVATION_INCREMENT_IN_DEGREES - nCurrentElevationInDegrees;
  }
  else if ( (nCurrentElevationInDegrees >= ELEVATION_CUTOFF_POINT_IN_DEGREES)) // If increasing elevation beyond the cutoff point (where objects are unlikely)
  {
    nElevationIncrementInDegrees = DEFAULT_ELEVATION_INCREMENT_IN_DEGREES * 2; // Double default elevation increment, sky is likely to be empty 
  }
  else
  {
    nElevationIncrementInDegrees = DEFAULT_ELEVATION_INCREMENT_IN_DEGREES; // Set default elevation increment 
  }
  
  if (nCurrentRotationInDegrees == MAXIMUM_ROTATION_IN_DEGREES) // If a full sweep to 360 degrees has been performed, tell the telescope to change direction
  {
    bRotateTowardsThreeSixty = false; 
  }  
  else if (nCurrentRotationInDegrees == MINIMUM_ROTATION_IN_DEGREES) // If the rotation has returned to the minimum, change direction
  {
     bRotateTowardsThreeSixty = true;
  }
  
  if (bRotateTowardsThreeSixty) // INCREASE rotation by increment if telescope is moving from the minimum to the maximum rotation
  {
    nCurrentRotationInDegrees += nRotationIncrementInDegrees;
  }
  else // DECREASE rotation by increment if telescope is moving from the maximum to the minimum rotation
  {
    nCurrentRotationInDegrees -= nRotationIncrementInDegrees;
  }

  /* If the telescope has completed a sweep from minimum to maximum rotation or vice-versa, all the data for the current altitude has been recorded */
  if ( (nCurrentRotationInDegrees == MINIMUM_ROTATION_IN_DEGREES && !bRotateTowardsThreeSixty) || 
       (nCurrentRotationInDegrees == MAXIMUM_ROTATION_IN_DEGREES && bRotateTowardsThreeSixty)
     ) 
  {
    addPositionToSchedule(); // Add the current position to the schedule
    nCurrentElevationInDegrees += nElevationIncrementInDegrees; // Finished all readings at this altitude, increase elevation
  }
}

